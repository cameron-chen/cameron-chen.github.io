<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Import TF Graph for Fine-tuning - Think Different</title>
<link rel="shortcut icon" href="https://cameron-chen.github.io/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://cameron-chen.github.io/media/css/tailwind.css">
<link rel="stylesheet" href="https://cameron-chen.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Import TF Graph for Fine-tuning - Think Different - Atom Feed" href="https://cameron-chen.github.io/atom.xml">


  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-166618662-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-166618662-1');
  </script>
    

  <meta name="description" content="
This post is motivated by a task in research: import a pretrained model, e.g. GAN, continue updating one part of its co..." />
  <meta property="og:title" content="Import TF Graph for Fine-tuning - Think Different">
  <meta property="og:description" content="
This post is motivated by a task in research: import a pretrained model, e.g. GAN, continue updating one part of its co..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://cameron-chen.github.io/import-tf-graph-for-fine-tuning/" />
  <meta property="og:image" content="https://owncloud-c.oss-cn-shanghai.aliyuncs.com/img/tf_logo.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="Import TF Graph for Fine-tuning - Think Different">
  <meta name="twitter:description" content="
This post is motivated by a task in research: import a pretrained model, e.g. GAN, continue updating one part of its co...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://cameron-chen.github.io/import-tf-graph-for-fine-tuning/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://cameron-chen.github.io/media/css/prism-atom-dark.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://cameron-chen.github.io" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      Think Different
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          Import TF Graph for Fine-tuning
        </h1>
        
          <img src="https://owncloud-c.oss-cn-shanghai.aliyuncs.com/img/tf_logo.png" alt="Import TF Graph for Fine-tuning" class="block w-full mb-8">
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2021-10-09 · 7 min read</div>
          
            <a href="https://cameron-chen.github.io/tag/rRH6sFx9l/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              tensorflow
            </a>
          
            <a href="https://cameron-chen.github.io/tag/NdNJ0koPS/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              academic
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <blockquote>
<p>This post is motivated by a task in research: import a pretrained model, e.g. GAN, continue updating one part of its components, e.g. discriminator, while freeze the other, e.g. generator. When the pretrained model is implemented by TensorFlow1, one critical step is to import the graph of the model and restore the key nodes. I will first introduce some basic concepts in TensorFlow and then one way to achieve the task.</p>
</blockquote>
<ul>
<li><a href="#graph_type">Type of Graph</a></li>
<li><a href="#gen_way">Model Saving &amp; Loading: A General Way</a></li>
<li><a href="#gentle_way">Model Saving &amp; Loading: A More Gentle Way</a></li>
</ul>
<p>Many tasks require pretrained models, e.g. few-shot learning, and it turns out many official implementations are on TensorFlow1, especially in earlier years. I had a task in research: I need a pretrained GAN, implemented on TensorFlow, as part of my own model. The pretrained generator is for generating fake sample (thus freeze parameters), and the pretrained discriminator is for providing loss (thus update parameters). So, this essentially requires to import the model, connect the imported model with my own, and provide the access to the key nodes in the graph (TensorFlow performs computation via computational graph), meanwhile, avoid naming conflicts.</p>
<p>However, it turns out no tutorial, either official web or academic blogs, has provided solutions. Here I would like to share one way to do it and, before that, I will introduce some basic concepts.</p>
<p>Again, this tutorial works for TensorFlow1 and solves the problem on how to import pretrained model (graph) into an existing model.</p>
<h2 id="type-of-graph-a-namegraph_typea">Type of Graph <a name="graph_type"></a></h2>
<p>There are three types of graph in TensorFlow, say <code>tf.Graph()</code> object (denoted as Graph Object), GraphDef and MetaGraph. When we build a model on TensorFlow, we develop a Graph Object. For GraphDef and MetaGraph, they are lower-level abstraction which benefits communication in TensorFlow, model saving and loading, etc.</p>
<p><strong>Graph Object</strong>. Graph Object is a set of operations (computations) and tensors. We construct a Graph Object to instantiate a model with Python API of TensorFlow.</p>
<p><strong>GraphDef</strong>. GraphDef (full name: GraphDef protocol buffer)  is serialized representation of the Graph Object. GraphDef can be saved and used to do inference. However, do note we cannot retrain or fine-tune a model imported from GraphDef as it do not record the information of <code>tf.Variable()</code>, so we cannot restore a complete Graph Object by GraphDef.</p>
<p><strong>MetaGraph</strong>. As described in a <a href="https://chromium.googlesource.com/external/github.com/tensorflow/tensorflow/+/r0.10/tensorflow/g3doc/how_tos/meta_graph/index.md">tutorial</a>, a MetaGraph consists of GraphDef as well as associated metadata necessary for running computation in a graph when crossing a process boundary. A MetaGraph contains the information required to (1) continue training, (2) perform evaluation, (3) run inference. However, do note that we still need to restore the actually values of <code>tf.Variable()</code> (weights of neural network) as the values of <code>tf.Variable()</code> are randomly initialized when we restore a Graph Object from a MetaGraph.</p>
<p>I have introduced three types of graphs in TensorFlow. It turns out none of them directly enable us to continue training of a pretrained model. In next section, I will introduce a general way to save and load a model.</p>
<h2 id="model-saving-loading-a-general-way-a-namegen_waya">Model Saving &amp; Loading: A General Way <a name="gen_way"></a></h2>
<p>To save &amp; load a model, TensorFlow provides API <code>tf.train.Saver()</code>. A simple example can be:</p>
<pre><code class="language-python"># Save
saver = tf.train.Saver()
sess = tf.Session()
saver.save(sess, 'my-model') # save a model named 'my-model'

# ...
# Load
saver = tf.train.import_meta_graph(os.path.join('/path/to/my-model', meta_file))
saver.restore(tf.get_default_session(), os.path.join('/path/to/check_dir', ckpt_file))

</code></pre>
<p>Note that <code>meta_file</code> and <code>ckpt_file</code> are in the folder <code>my-model</code>. This API is straightforward and can save &amp; load the complete pretrained model. But it is still not enough to solve my problem.</p>
<p>Now, let's recall the task:</p>
<ul>
<li>Save &amp; load the pretrained model</li>
<li><span style="color:orange">Have access to key nodes</span></li>
<li><span style="color:orange">Avoid naming conflicts with existing graph</span></li>
<li><span style="color:orange">Placeholder-Tensor mapping</span>: connect the imported graph with my own</li>
</ul>
<p>The first requirement has been satisfied by <code>Saver()</code>. For the remainder, we will discuss in next section.</p>
<h2 id="model-saving-loading-a-more-gentle-way-a-namegentle_waya">Model Saving &amp; Loading: A More Gentle Way <a name="gentle_way"></a></h2>
<p>When we want to continue training a pretrained model, especially this pretrained model serves as a component of a bigger model, we need to satisfy the above requirements.</p>
<p><strong>Have access to key nodes</strong>. As <code>Saver()</code> loads the pretrained model (a Graph Object) as a whole, we need to retrieve the key nodes, e.g. loss node, from Graph Object. We can choose <code>tf.get_variable()</code> (need to provide the name, a string, of the queried variable). But a more gentle way is to add key nodes in a collection before save the model and to retrieve key nodes from the collection. A simple example can be:</p>
<pre><code class="language-python"># Model definition
pred = model_network(X)
loss=tf.reduce_mean(..., pred, ...)

# Add key nodes into a customized collection
tf.add_to_collection('key_nodes', pred)
tf.add_to_collection('key_nodes', loss)

# ...
# retrieve key nodes
pred, loss = tf.get_collection('key_nodes')

</code></pre>
<p><strong>Avoid naming conflicts with existing graph</strong>. Naming conflicts may exist between existing graph and imported graph. For example, TensorFlow assigns name &quot;add:0&quot; to the output tensor of the first add operation if the name is not specified. Therefore, we'd better assign a name scope to the imported graph. We can do this by argument <code>tf.train.import_meta_graph(import_scope = None)</code>. A simple example can be (refer to the example at section <a href="#gen_way">model saving &amp; loading: a general way</a>):</p>
<pre><code class="language-python"># Save

# ...
# Load
saver = tf.train.import_meta_graph(os.path.join('/path/to/my-model', meta_file), 
                                   import_scope = 'name_of_scope')

# ...

</code></pre>
<p><strong>Placeholder-Tensor mapping</strong>. One last thing is to connect the imported graph and the existing graph. In my use case, I need to feed the output of the existing graph into the imported graph. In other words, I replace the input (placeholder) of the imported graph with another tensor. This can be done when we import the graph. We can specify the argument <code>tf.train.import_meta_graph(input_map = None)</code>. A simple example can be (refer to the example at section <a href="">model saving &amp; loading: a general way</a>):</p>
<pre><code class="language-python"># Save

# ...
# Load
saver = tf.train.import_meta_graph(os.path.join('/path/to/my-model', meta_file), 
                                   import_scope = 'name_of_scope',
                                   input_map = {'original_placeholder_name:0': node_of_current_graph})

# ...

</code></pre>
<h2 id="references">References</h2>
<p>[1] zhihu.com <a href="https://zhuanlan.zhihu.com/p/31308381">TensorFlow 框架实现中的“三”种图</a></p>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#type-of-graph-a-namegraph_typea">Type of Graph <a name="graph_type"></a></a></li>
<li><a href="#model-saving-loading-a-general-way-a-namegen_waya">Model Saving &amp; Loading: A General Way <a name="gen_way"></a></a></li>
<li><a href="#model-saving-loading-a-more-gentle-way-a-namegentle_waya">Model Saving &amp; Loading: A More Gentle Way <a name="gentle_way"></a></a></li>
<li><a href="#references">References</a></li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://cameron-chen.github.io/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://cameron-chen.github.io/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script type="application/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script type="application/javascript">

  var gitalk = new Gitalk({
    clientID: 'b0b5994afc452f1e89d9',
    clientSecret: '21b4959726f9da0d7826e5151618e8cc08fe440d',
    repo: 'cameron-chen.github.io',
    owner: 'cameron-chen',
    admin: ['cameron-chen'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

    
  
</body>

</html>